# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input ChangeEmailInput {
  email: String!
  token: String!
}

input ChangePasswordInput {
  password: String!
  token: String!
}

input CreateRatingInput {
  productId: String!
  star: Int!
  text: String!
}

input CreateUserInput {
  activated: DateTime
  activationToken: String
  avatar: String
  email: String!
  emailToken: String
  emailTokenCreated: DateTime
  firstName: String!
  lastName: String!
  passwordToken: String
  passwordTokenCreated: DateTime
  phone: String
  rating: [ProductRatingInput!]
  role: Role
  title: String
  username: String
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DeleteResult {
  affected: Int!
  raw: [String!]!
}

type EmailResponse {
  rejected: [String!]!
  success: Boolean!
}

type FilterArgs {
  brand: [String]
  category: [String]
  priceMax: Float
  priceMin: Float
  ram: [Int]
  search: String
  storage: [Int]
}

input FilterArgsInput {
  brand: [String]
  category: [String]
  priceMax: Float
  priceMin: Float
  ram: [Int]
  search: String
  storage: [Int]
}

type LoginResponse {
  accessToken: String!
  user: User!
}

input LoginUserInput {
  email: String!
  password: String!
}

type Mutation {
  activateUser(token: String!): User!
  changeEmail(data: ChangeEmailInput!): UpdateResult!
  changePassword(data: ChangePasswordInput!): UpdateResult!
  createRating(data: CreateRatingInput!): ProductRating!
  removeCustomer: DeleteResult!
  removeUser(id: String!): DeleteResult!
  restoreCustomer: UpdateResult!
  restoreUser(id: String!): UpdateResult!
  signIn(data: LoginUserInput!): LoginResponse
  signUp(data: CreateUserInput!): RegisterResponse!
  updateCustomer(data: UpdateUserInput!): User!
  updateUser(data: UpdateUserInput!, id: String!): User!
}

input PaginationArgsInput {
  limit: Int!
  page: Int!
}

type Product {
  brand: ProductBrand!
  category: ProductCategory!
  created: DateTime
  deleted: DateTime
  description: String
  discount: Float
  id: String
  image: [ProductImage!]
  name: String!
  osUpgradable: Float
  price: Float!
  rating: [ProductRating!]
  ratingAverage: Float
  sku: String!
  stock: Int!
  thumbnail: String
  updated: DateTime
  warranty: Int
}

type ProductBrand {
  created: DateTime
  deleted: DateTime
  id: String
  name: String!
  product: Product
  updated: DateTime
}

input ProductBrandInput {
  name: String!
  product: ProductInput
}

type ProductCategory {
  created: DateTime
  deleted: DateTime
  id: String
  name: String!
  product: Product
  updated: DateTime
}

input ProductCategoryInput {
  name: String!
  product: ProductInput
}

type ProductImage {
  created: DateTime
  deleted: DateTime
  id: String
  product: Product
  updated: DateTime
  url: String!
}

input ProductImageInput {
  product: ProductInput
  url: String!
}

input ProductInput {
  brand: ProductBrandInput!
  category: ProductCategoryInput!
  description: String
  discount: Float
  image: [ProductImageInput!]
  name: String!
  osUpgradable: Float
  price: Float!
  rating: [ProductRatingInput!]
  ratingAverage: Float
  sku: String!
  stock: Int!
  thumbnail: String
  warranty: Int
}

type ProductRating {
  created: DateTime
  deleted: DateTime
  id: String
  product: Product!
  star: Int!
  text: String!
  updated: DateTime
  user: User!
}

input ProductRatingInput {
  product: ProductInput!
  star: Int!
  text: String!
  user: UserInput!
}

type ProductsFetchResponse {
  count: Int!
  data: [Product!]!
  filter: FilterArgs
  limit: Int!
  page: Int!
}

input ProductsFetchResponseInput {
  count: Int!
  data: [ProductInput!]!
  filter: FilterArgsInput
  limit: Int!
  page: Int!
}

type Query {
  fetchCustomer: User!
  product(id: String!): Product!
  products(filterArgs: FilterArgsInput, paginationArgs: PaginationArgsInput, sortArgs: SortArgsInput): ProductsFetchResponse!
  ratings: [ProductRating!]!
  requestEmailChange(email: String!): EmailResponse!
  requestPasswordChange(email: String!): EmailResponse!
  user(id: String!): User!
  users: [User!]!
  verifyToken(token: String!, tokenOption: String!): TokenVerificationResponse!
}

type RegisterResponse {
  message: String!
  success: Boolean!
}

enum Role {
  ADMIN
  CUSTOMER
  PRODUCT_MANAGEMENT
}

input SortArgsInput {
  sortBy: String!
  sortDir: String!
}

type TokenVerificationResponse {
  valid: Boolean!
}

type UpdateResult {
  affected: Int!
  generatedMaps: [String!]!
  raw: [String!]!
}

input UpdateUserInput {
  activated: DateTime
  activationToken: String
  avatar: String
  created: DateTime
  deleted: DateTime
  email: String
  emailToken: String
  emailTokenCreated: DateTime
  firstName: String
  id: String
  lastName: String
  passwordToken: String
  passwordTokenCreated: DateTime
  phone: String
  rating: [ProductRatingInput!]
  role: Role
  title: String
  updated: DateTime
  username: String
}

type User {
  activated: DateTime
  activationToken: String
  avatar: String
  created: DateTime
  deleted: DateTime
  email: String!
  emailToken: String
  emailTokenCreated: DateTime
  firstName: String!
  id: String
  lastName: String!
  passwordToken: String
  passwordTokenCreated: DateTime
  phone: String
  rating: [ProductRating!]
  role: Role
  title: String
  updated: DateTime
  username: String
}

input UserInput {
  activated: DateTime
  activationToken: String
  avatar: String
  email: String!
  emailToken: String
  emailTokenCreated: DateTime
  firstName: String!
  lastName: String!
  passwordToken: String
  passwordTokenCreated: DateTime
  phone: String
  rating: [ProductRatingInput!]
  role: Role
  title: String
  username: String
}